@title UMLErl - a tool for executing UML State machines
using Erlang
@author Lars-Ake Fredlund (lfredlund@fi.upm.es)
@doc UMLErl is a tool for executing UML State Machine descriptions.
In essence, it is an interpreter for UML State Machines written
in the Erlang programming language. Due to the clean
design of the interpreter, it is possible to either execute
state machine, or to verify them using a model checker
(e.g., <a href="https://babel.ls.fi.upm.es/trac/McErlang/wiki">McErlang</a>).
<p>
UMLErl currently does not have support for simulating UML 
state machines which are written in UML graphical syntax.
An interface from XML-based XMI format is being prototyped,
but is not yet ready. The consequence is that UML state machines
are written in an internal format, which is a mix of Erlang
and UML syntax, and the actions of the state machines
are expressed as Erlang functions. In the following we document 
the internal format of the state machines, and provide examples
to illustrate how UML behaviour can be encoded in Erlang functions.
</p>

<h2>Installing UMLErl</h2>
To install UMLErl first Erlang must be installed. If Erlang is
not already installed on your operating system consult the
<a href="www.erlang.org">Erlang web site</a> for instructions
on how to install it. In the following we assume that a Linux-based
operating system is used, although UMLErl can be installed
on e.g. Windows too.

To use UMLErl it simply has to be compiled:
```
$ make
'''

<h2>An Example</h2>
As an example we will consider how work with the <a href="http://en.wikipedia.org/wiki/Dining_philosophers_problem">Dining
Philosopher problem</a> in UMLErl. The specification of
the philosopher as a state machine is depicted below<br/><br/>
<div style="text-align: center;">
<img src="phil.png">
</img>
</div>
<br/>
and the fork is:
<div style="text-align: center;">
<img src="fork.png">
</img>
</div>
<br/>

The codification of the above state machines is show below in
section...

In the following we assume that the codification
of the philosopher and fork state machines are stored
in the files ``philosopher.erl'' and ``fork.erl'' respectively. First,
we have to invoke the Erlang compiler on these files (in the following
we assume a Linux-based system). It is assumed that the current
working directory is the top directory of the UMLErl distribution.
```
$ cd examples                                          # move to examples directory
$ erlc philosopher.erl fork.erl table.erl -pz ../ebin  # recompile the dining example
'''

The file ``table.erl'' contains the Erlang code to start the dining philosopher
and is shown below:
```
-module(table).
-compile(export_all).

table(N) ->
  Forks = lists:map (fun (_) -> process:start([{fork,void}]) end, lists:seq(1,N)),
  lists:foreach
    (fun ({L,R}) -> process:start([{philosopher,{L,R}}]) end, adjacent(Forks)).

adjacent([]) -> [];
adjacent([X|Xs]) -> lists:zip([X] ++ Xs, Xs ++ [X]).
'''
The main function in ``table(N)'' which provided a natural number ``N'',
creates a table with ``N'' philosophers and ``N'' forks.

We let each state machine run in their own machine container.
In the simulator/verifier, each container is mapped to a unique Erlang 
process, and we will hence use the terminology container/process interchangeably.

Such a container, with machines, is created using the
function ``process:start(ListOfMachines)'' (further documentation available
in the Modules section to the left).
In the call ``process:start([{philosopher,{L,R}}])'', for example,
a new process is started with one associated state machine. The
machine is implemented by the Erlang module ``philosopher'',
and the machine receives as initial arguments 
(``fL'' and ``fR'' in the philosopher state machine above)
the addresses (Erlang pids) to its left and right fork processes.

We can now run, e.g., simulate, a table with two philosophers and forks:
```
$ erl -pz ../ebin/
Erlang R16B02 (erts-5.10.3) [source] [64-bit] [smp:12:12] [async-threads:10] [hipe] [kernel-poll:false]

Eshell V5.10.3  (abort with ^G)
1> table:table(2).
ok
2> 
'''
As we did not include any printouts in the philosophers and forks
nothing was printed. We can suspect that there is a deadlock in the
system, and one way to prove it is to use the <a href="https://babel.ls.fi.upm.es/trac/McErlang/">Erlang model checker</a> to find it.

<h3>Using McErlang to debug the Dining Philosopher problem</h3>

<h2>UML State Machine format description</h2>

@end



