@title UMLErl - a tool for executing UML State machines
using Erlang
@author Lars-Ake Fredlund (lfredlund@fi.upm.es)
@doc UMLErl is a tool for executing UML State Machine descriptions.
In essence, it is an interpreter for UML State Machines written
in the Erlang programming language. Due to the clean
design of the interpreter, it is possible to either execute
state machine, or to verify them using a model checker
(e.g., <a href="https://babel.ls.fi.upm.es/trac/McErlang/wiki">McErlang</a>).
<p>
UMLErl currently does not have support for simulating UML 
state machines which are written in UML graphical syntax.
An interface from XML-based XMI format is being prototyped,
but is not yet ready. The consequence is that UML state machines
are written in an internal format, which is a mix of Erlang
and UML syntax, and the actions of the state machines
are expressed as Erlang functions. In the following we document 
the internal format of the state machines, and provide examples
to illustrate how UML behaviour can be encoded in Erlang functions.
</p>

<h2>Installing UMLErl</h2>
To install UMLErl first Erlang must be installed. If Erlang is
not already installed on your operating system consult the
<a href="www.erlang.org">Erlang web site</a> for instructions
on how to install it. In the following we assume that a Linux-based
operating system is used, although UMLErl can be installed
on e.g. Windows too.

To use UMLErl it simply has to be compiled:
```
$ make
'''

<h2>An Example</h2>
As an example we will consider how work with the <a href="http://en.wikipedia.org/wiki/Dining_philosophers_problem">Dining
Philosopher problem</a> in UMLErl. The specification of
the philosopher as a state machine is depicted below<br/><br/>
<div style="text-align: center;">
<img src="phil.png">
</img>
</div>
<br/>
and the fork is:
<div style="text-align: center;">
<img src="fork.png">
</img>
</div>
<br/>

The codification of the above state machines is show below in
section...

In the following we assume that the codification
of the philosopher and fork state machines are stored
in the files ``philosopher.erl'' and ``fork.erl'' respectively. First,
we have to invoke the Erlang compiler on these files (in the following
we assume a Linux-based system). It is assumed that the current
working directory is the top directory of the UMLErl distribution.
```
$ cd examples                                          # move to examples directory
$ erlc philosopher.erl fork.erl table.erl -pa ../ebin  # recompile the dining example
'''

The file ``table.erl'' contains the Erlang code to start the dining philosopher
and is shown below:
```
-module(table).
-compile(export_all).

table(N) ->
  Forks = lists:map (fun (_) -> process:start([{fork,void}]) end, lists:seq(1,N)),
  lists:foreach
    (fun ({L,R}) -> process:start([{philosopher,{L,R}}]) end, adjacent(Forks)).

adjacent([]) -> [];
adjacent([X|Xs]) -> lists:zip([X] ++ Xs, Xs ++ [X]).
'''
The main function in ``table(N)'' which provided a natural number ``N'',
creates a table with ``N'' philosophers and ``N'' forks.

We let each state machine run in their own machine container.
In the simulator/verifier, each container is mapped to a unique Erlang 
process, and we will hence use the terminology container/process interchangeably.

Such a container, with machines, is created using the
function ``process:start(ListOfMachines)'' (further documentation available
in the Modules section to the left).
In the call ``process:start([{philosopher,{L,R}}])'', for example,
a new process is started with one associated state machine. The
machine is implemented by the Erlang module ``philosopher'',
and the machine receives as initial arguments 
(``fL'' and ``fR'' in the philosopher state machine above)
the addresses (Erlang pids) to its left and right fork processes.

We can now run, e.g., simulate, a table with two philosophers and forks:
```
$ erl -pa ../ebin/
Erlang R16B02 (erts-5.10.3) [source] [64-bit] [smp:12:12] [async-threads:10] [hipe] [kernel-poll:false]

Eshell V5.10.3  (abort with ^G)
1> table:table(2).
ok
2> 
'''
As we did not include any printouts in the philosophers and forks
nothing was printed. We can suspect that there is a deadlock in the
system, and one way to prove it is to use the <a href="https://babel.ls.fi.upm.es/trac/McErlang/">Erlang model checker</a> to find the deadlock.

<h3>Using McErlang to debug the Dining Philosopher problem</h3>

In the following we assume that McErlang is already installed,
and that the current working directory is ``examples''.

First we have to recompile the sources for the Dining Philosopher
problem using McErlang:

```
$ mkdir mcerlang_ebin             # a temporary working dir
$ mcerl_compiler -pa ../ebin -output_dir mcerlang_ebin -sources ../src/*.erl fork.erl philosopher.erl table.erl
'''

Note that above we in fact also recompiled the sources for the whole 
UMLErl interpreter; thus the UMLErl interpreter will run under the control
of the McErlang model checker.

We can now run the Dining Philosopher example in McErlang:
```
$ mcerl -pa mcerlang_ebin 
Erlang R16B02 (erts-5.10.3) [source] [64-bit] [smp:12:12] [async-threads:10] [hipe] [kernel-poll:false]

Eshell V5.10.3  (abort with ^G)

1> rr(mce:find_mce_opts()).
[mce_opts]

2> mce:start(#mce_opts{program=fun () -> table:table(2) end}).
Starting McErlang model checker version
"McErlang 2.1.1 [revision ++ compiled on lun nov 4 11:45:04 CET 2013]" ...

...
*** Run ending. 276 states explored, stored states 157.

...
ok
3> mce:start(#mce_opts{program=fun () -> table:table(2) end,monitor=mce_mon_deadlock}).
Starting McErlang model checker version
"McErlang 2.1.1 [revision ++ compiled on lun nov 4 11:45:04 CET 2013]" ...

...
*** Monitor failed
monitor error:
deadlock
Table has 11 states and 11 transitions.
Stack depth 1 entries.
'''

First in line ``1>'' we obtain the definition of the ``#mce_opts'' records
which is used to specify what McErlang should attempt to verify
(see the McErlang manual for further explanations).
In line ``2>'' then we check that the Dining Philosopher problem, with
two philosophers, does not raise any runtime exception
(checking for the absence of runtime exceptions is the default 
action of McErlang), which it apparently doesn't.
Then, in line ``3>'' we check whether there are any deadlocks
by specifying the monitor (correctness property) ``mce_mon_deadlock'',
and indeed, McErlang quickly finds an error. We could then
proceed to investigate the error using e.g. the McErlang debugger, showing 
the trace that leads to the error, but that exercise is left to the reader.

<h2>UML State Machine format description</h2>

@end



